import React, { useState, useEffect, useRef, useMemo } from 'react';
import PropTypes from 'prop-types';
import { useTranslation } from 'react-i18next';
import { CSVLink } from 'react-csv';

import { TABLE_PAGINATION_ALL } from '/util';
import { Button } from '@mui/material';
import { GetApp as FileDownload } from '@mui/icons-material';
import { formatAdminBids, formatDate } from '/util/formatters';

// Rendering this component automatically triggers CSV download.
const TriggerCSVDownload = (props) => {
  const btnRef = useRef(null);
  useEffect(() => btnRef.current.click(), [btnRef]);
  return (
    <CSVLink {...props} separator=';'>
      <span ref={btnRef} />
    </CSVLink>
  );
};

const CSVDownload = ({ tableData }) => {
  const { t } = useTranslation();

  const [csvData, setCsvData] = useState([]);
  const [csvHeaders, setCsvHeaders] = useState([]);
  const [extraColumns, setExtraColumns] = useState({ headers: [], data: [] });
  const [downloadClicked, setDownloadClicked] = useState(false);
  const [didCSVComputation, setDidCSVComputation] = useState(false);
  const [prevPageSize, setPrevPageSize] = useState(30);

  const FIELDS_TO_IGNORE = [t('common.actions.actions'), t('components.inventory_statuses.preview')];

  const { page, headers, pageSize, setPageSize, rawData } = tableData;
  const headerIds = headers ? headers.map((header) => ({ [header.id]: header.Header })) : [];

  // Process certain data from the table to make sure CSV entries are pretty and human readable.
  const customFormatData = (key, row) => {
    const values = row.values;
    const value = values[key];
    if (typeof value === 'boolean') return value ? t('common.actions.yes') : t('common.actions.no');

    switch (key) {
      case 'lastSeen':
      case 'lastLogin':
      case 'lastCall':
      case 'startTime':
      case 'endTime':
        return new Date(value).toGMTString();

      case 'nearFutureRisk': {
        return `${
          row.original['nearFutureRisk']
            ? t(`components.toggle_button_group.${row.original['nearFutureRisk']}`)
            : t('errors.unknown')
        }, ${
          row.original['severeViolenceRisk']
            ? t(`components.toggle_button_group.${row.original['severeViolenceRisk']}`)
            : t('errors.unknown')
        }`;
      }

      case 'completedAt':
        return `${row.original['completedAt'] ? formatDate(row.original['completedAt']) : t('errors.unknown')}, ${
          row.original['adminBids'] ? formatAdminBids(row.original['adminBids']) : t('errors.unknown')
        }`;

      case undefined:
        return t('errors.unknown');

      default:
        return `${value}`;
    }
  };

  // This useEffect is the where the main functionality resides, responsible for most of the logic.
  // The logic is a little bit convoluted. We have to make sure that when the
  // "Download CSV" button is pressed, ALL data is included. This is a little bit
  // finnicky because we rely on the data generated by react-table for the CSV content,
  // and by default that's only going to include the current page. So when the user clicks
  // the Download button, we first set the rowsPerPage to "All" for the table, then
  // once that has taken effect in a new render we detect that here and generate the
  // CSVContent (we don't do this until now to avoid unneccesary processing).
  // We then set setDidCSVComputation=true, which makes the <TriggerCSVDownload />
  // component render once on the next cycle, triggering the download. The page size
  // is finally reset to the same size the user had originally and internal flags are reset.
  // (finnss Oct 2022)
  useEffect(() => {
    if (pageSize !== TABLE_PAGINATION_ALL && prevPageSize !== pageSize) {
      // Keep track of which page size the user actually has chosen so we can go back to it later
      setPrevPageSize(pageSize);
    } else if (pageSize === TABLE_PAGINATION_ALL && downloadClicked && !didCSVComputation && page) {
      // Perform computation of CSV file content.
      //
      // The 'page' variable is a list of table rows including all metadata, and each such row includes
      // amongst other things the 'values' attribute which is an object on the form of
      // { columnAccessor: valueForThisRow }, so for example { nickname: 'Device 4', imei: 123... }

      const newCsvData = page.map((row) =>
        Object.keys(row.values)
          .filter((key) => !FIELDS_TO_IGNORE.includes(key))
          .sort((a, b) => headerIds.indexOf(a) - headerIds.indexOf(b))
          .map((key) => customFormatData(key, row))
      );
      setCsvData(newCsvData);
      setDidCSVComputation(true);
    } else if (pageSize === TABLE_PAGINATION_ALL && downloadClicked && didCSVComputation) {
      // Reset after download is done
      setDownloadClicked(false);
      setDidCSVComputation(false);
      setExtraColumns({ headers: [], data: [] });
      setPageSize(prevPageSize);
    }
  }, [didCSVComputation, pageSize, page, headers]);

  useEffect(() => {
    setCsvHeaders(
      headers ? headers.map((column) => column.Header).filter((header) => !FIELDS_TO_IGNORE.includes(header)) : []
    );
  }, [headers]);

  const pathnameParts = window.location.pathname.split('/');
  const currentPageName = pathnameParts[pathnameParts.length - 1];
  const date = new Date();
  // Really ugly formatting, but from my googling I couldn't find a better way of getting
  // "2022-11-01 12:32:16"-type formatting without using a library.
  // FIXME Maybe using a datetime library is worth it to avoid this kind of stuff? (finnss Oct 2022)
  const fileName = `alfa-${currentPageName}-${date.getFullYear()}-${
    date.getMonth() + 1
  }-${date.getDate()}T${date.getHours()}-${date.getMinutes()}-${date.getSeconds()}.csv`;

  const finalCsvHeaders = useMemo(() => [...csvHeaders, ...extraColumns.headers], [csvHeaders, extraColumns]);
  const finalCsvData = useMemo(
    () => csvData.map((row, i) => [...row, ...extraColumns.data.map((extraRow) => extraRow[i])]),
    [csvData, extraColumns]
  );

  return (
    <Button
      variant='outlined'
      startIcon={<FileDownload />}
      onClick={() => {
        setDownloadClicked(true);
        setPageSize(TABLE_PAGINATION_ALL);
      }}>
      {t('common.strings.export_to_file')}
      {pageSize === TABLE_PAGINATION_ALL && downloadClicked && didCSVComputation && (
        <TriggerCSVDownload headers={finalCsvHeaders} data={finalCsvData} filename={fileName} />
      )}
    </Button>
  );
};

CSVDownload.propTypes = {
  tableData: PropTypes.object.isRequired,
};

export default CSVDownload;
